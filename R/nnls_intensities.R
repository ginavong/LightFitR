#' Use non-linear least squares to interpolate intensities
#'
#' @inheritParams internal.calibCombine
#' @inheritParams internal.closestIntensities
#' @param closest_intensities  Matrix of closest intensities, generated by `internal.closestIntensities`. Same format as `irradiance_matrix`
#'
#' @return
#' @export
#'
#' @examples
nnls_intensities = function(irradiance_matrix, closest_intensities, calibration_leds, calibration_wavelengths, calibration_intensities, calibration_irradiances, peaks=helio.dyna.leds$wavelength){

  # Setup

  calib = internal.calibCombine(calibration_leds, calibration_wavelengths, calibration_intensities, calibration_irradiances)

  ## Checks
  LightFitR:: helio.checkFormat(irradiance_matrix)
  LightFitR:: helio.checkWhite(irradiance_matrix)
  LightFitR::helio.checkFormat(closest_intensities)
  LightFitR::helio.checkWhite(closest_intensities)
  LightFitR::checkRange(irradiance_matrix, calib$led, calib$wavelength, calib$intensity, calib$irradiance)

  # NNLS

  intensities_mat = sapply(1:ncol(closest_intensities), function(i){

    # Make a dataframe with only the info we need for this event
    tempDf = data.frame(led=LightFitR::helio.dyna.leds[-9, 'wavelength'], closest=closest_intensities[,i], intended=irradiance_matrix[-9,i])

    # Make a matrix of irradiances to input into nnls function
    mat = sapply(1:nrow(tempDf), function(j){
      criteria = (calib$led == tempDf[j, 'led']) & (calib$intensity == tempDf[j, 'closest']) & (calib$wavelength %in% peaks) # We want the irradiances (from calib data) of each LED at the intensity where it is closest to the intended irradiance
      calib[criteria, 'irradiance']
    })

    # Run the NNLS model
    mod = nnls::nnls(mat, tempDf[,'intended'])

    # Calculate intensities
    intensities = mod$x * tempDf[, 'closest'] # This should be a vector
  })

  image(intensities_mat, main='predicted intensities')

  return(intensities_mat)
}
